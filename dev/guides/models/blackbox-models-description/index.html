<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Blackbox models description · AutomationLabs.jl</title><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">AutomationLabs.jl</a></span></div><form class="docs-search" action="../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><span class="tocitem">Home</span><ul><li><a class="tocitem" href="../../../">AutomationLabs.jl documentation</a></li></ul></li><li><span class="tocitem">Installation</span><ul><li><a class="tocitem" href="../../../installation/installation/">Installation with Julia</a></li></ul></li><li><span class="tocitem">Quick start</span><ul><li><a class="tocitem" href="../../../quick_start/introductory/">Introduction</a></li><li><a class="tocitem" href="../../../quick_start/manage-your-first-data/">Manage your first data</a></li><li><a class="tocitem" href="../../../quick_start/tune-your-first-model/">Tune your first model</a></li><li><a class="tocitem" href="../../../quick_start/tune-your-first-controller/">Tune your first controller</a></li></ul></li><li><span class="tocitem">Guides</span><ul><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Administrate projects</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../projects/administrate-projects/">Interact with projects</a></li><li><a class="tocitem" href="../../projects/parameters/">Parameters</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Administrate data</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../data/administrate-data/">Interact with data</a></li><li><a class="tocitem" href="../../data/parameters/">Parameters</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-3" type="checkbox" checked/><label class="tocitem" for="menuitem-4-3"><span class="docs-label">Administrate models</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../administrate-models/">Interact with models</a></li><li class="is-active"><a class="tocitem" href>Blackbox models description</a><ul class="internal"><li><a class="tocitem" href="#Parametric"><span>Parametric</span></a></li><li><a class="tocitem" href="#Neural-networks"><span>Neural networks</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../hyperparameters-optimization/">Hyperparameters optimization</a></li><li><a class="tocitem" href="../exploration-of-models/">Exploration of models</a></li><li><a class="tocitem" href="../loss-function/">Loss functions</a></li><li><a class="tocitem" href="../solvers/">Solvers</a></li><li><a class="tocitem" href="../manage-the-electronic-circuit/">Manage the electronic circuit</a></li><li><a class="tocitem" href="../parameters/">Parameters</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">Administrate controllers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../controllers/administrate-controllers/">Interact with controllers</a></li><li><a class="tocitem" href="../../controllers/model-predictive-control/">Model predictive control</a></li><li><a class="tocitem" href="../../controllers/economic-model-predictive-control/">Economic model predictive control</a></li><li><a class="tocitem" href="../../controllers/solvers/">Solvers</a></li><li><a class="tocitem" href="../../controllers/parameters/">Parameters</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-5" type="checkbox"/><label class="tocitem" for="menuitem-4-5"><span class="docs-label">Administrate dashboards</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../dashboards/administrate-dashboards/">Interact with dashboards</a></li><li><a class="tocitem" href="../../dashboards/parameters/">Parameters</a></li></ul></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../../../reference/cli/">CLI</a></li></ul></li><li><span class="tocitem">Collaboration</span><ul><li><a class="tocitem" href="../../../collaboration/how-to-contribute/">How to contribute</a></li></ul></li><li><span class="tocitem">Roadmap</span><ul><li><a class="tocitem" href="../../../roadmap/planned-for-v0.2.x/">Planned for v2.0.x</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Guides</a></li><li><a class="is-disabled">Administrate models</a></li><li class="is-active"><a href>Blackbox models description</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Blackbox models description</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/AutomationLabs-sh/AutomationLabs.jl/blob/main/docs/src/guides/models/blackbox-models-description.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Blackbox-models-description"><a class="docs-heading-anchor" href="#Blackbox-models-description">Blackbox models description</a><a id="Blackbox-models-description-1"></a><a class="docs-heading-anchor-permalink" href="#Blackbox-models-description" title="Permalink"></a></h1><h2 id="Parametric"><a class="docs-heading-anchor" href="#Parametric">Parametric</a><a id="Parametric-1"></a><a class="docs-heading-anchor-permalink" href="#Parametric" title="Permalink"></a></h2><h3 id="Linear-model"><a class="docs-heading-anchor" href="#Linear-model">Linear model</a><a id="Linear-model-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-model" title="Permalink"></a></h3><p>The linear model is the simplest model with only a wieights matric, it is defined as:</p><p class="math-container">\[h = W(v)\]</p><p>where, <span>$h$</span> is the output, <span>$W$</span> is a weighting matrix and <span>$v$</span> is the input. In the case of the dynamical system identification with <span>$h$</span> the predicted state (<span>$\hat{x}_{k+1}$</span>) and <span>$v$</span> the state and input at current time (<span>$x[k], u[k]$</span>) , the linear model can be redesign as classical linear state space model:</p><p class="math-container">\[\hat{x}[k+1] = A x[k] + Bu[k]\]</p><p>where, <span>$A$</span> is the state matrix and <span>$B$</span> the input matrix from <span>$W$</span>. The Linear model can be selected with <code>model_architecture</code>:</p><pre><code class="language-julia hljs">julia&gt; model(:tune; 
        project_name = &quot;name&quot;,
        model_name = &quot;model&quot;,
        io = &quot;io_name&quot;,
        computation_solver = &quot;lls&quot;,
        model_architecture = &quot;linear&quot;, 
    )</code></pre><p>where <code>project_name</code> the name of the related project, <code>model_name</code> the name of the model when saving on the database, <code>io</code> the name of input-output data, <code>computation_solver</code> the solver selected, and <code>model_architecture</code> the mathematical model selected.</p><h2 id="Neural-networks"><a class="docs-heading-anchor" href="#Neural-networks">Neural networks</a><a id="Neural-networks-1"></a><a class="docs-heading-anchor-permalink" href="#Neural-networks" title="Permalink"></a></h2><p>The artificial neuron is derived from the biological neuron. Modelling a biological neuron is complex and, its mathematical modelling is carried out with several simplifying assumptions, retaining only the basic principle of its ability to communicate through electrical signals. A illustration of a biological description is:</p><p><img src="../Complete_neuron_cell_diagram_en.png" alt="neuron-cell-diagram"/></p><p>Diagram of the simplification of the biological neuron, from By LadyofHats - Own work. Image renamed from Image:Complete neuron cell diagram.svg, Public Domain, https://commons.wikimedia.org/w/index.php?curid=3970826.</p><p>The first mathematical model of a neuron was proposed by W. McCulloch and W. Pitts after observation of frog neurons [1]. The model has a activation with output equal to 1 or 0. If the inputs connected to the neuron are activated above a certain threshold, then the output of the neuron becomes equal to 1 [2]. The artificial neurons commonly used for machine learning are different from the McCulloch and Pitts model. The artificial neuron has an activation function, weights and bias [3], and the mathematical formulation is equal to:</p><p class="math-container">\[h=\sigma(Wv+b)\]</p><p>where, <span>$h$</span> is the output, <span>$\sigma$</span> is the activation function, <span>$W$</span> is the weighting matrix, <span>$v$</span> is the input vetor, and <span>$b$</span> the the bias vector.</p><h3 id="Feedforward-neural-network-(Fnn)"><a class="docs-heading-anchor" href="#Feedforward-neural-network-(Fnn)">Feedforward neural network (Fnn)</a><a id="Feedforward-neural-network-(Fnn)-1"></a><a class="docs-heading-anchor-permalink" href="#Feedforward-neural-network-(Fnn)" title="Permalink"></a></h3><p>The artificial neurons are stacked in deep manner to form the feedforward neural network. A representation of the network with one hidden layer is:</p><p><img src="../fnn.png" alt="fnn-diagram"/></p><p>In the special case where the network has one hidden layer, a finite number of neurons and the sigmoid activation function, then the network can approximate any continuous continuous function [4] and it proves to be a universal approximator [5]. The generic mathematical formulation is [6]:</p><p class="math-container">\[h=\mathcal{G}(v) = g_{h¹}(v)\ \circ g_{h²} (h¹) \circ ... \circ g_{h^{i-1}} (h^{i-2}) \circ g_{h^{i}}(h^{i-1})\]</p><p>where <span>$h$</span> is the output vector of the neural networks, <span>$v$</span> is the input vecteur, <span>$\ron$</span> is the hadamard product, <span>$g_{h^i} is the imeme hidden layer with $$h^{i}=g_{h^i}(h^{i-1})=\sigma^i(W^ih^{i-1}+b^i)$</span> with <span>$h^i$</span> the output, hi-1 the input, <span>$\sigma^i$</span> the activation function, <span>$b^i$</span> tha bias, <span>$W$</span> is the weighting matrice and <span>$i$</span> is the hidden layer.</p><p>Within AutomationLabs, the Fnn input and output layer are implemented without bias and activation fuction. The Fnn can be selected with <code>model_architecture</code>:</p><pre><code class="language-julia hljs">julia&gt; model(:tune; 
        project_name = &quot;name&quot;,
        model_name = &quot;model&quot;,
        io = &quot;io_name&quot;,
        computation_solver = &quot;adam&quot;,
        computation_maximum_time = Dates.Minute(5),
        model_architecture = &quot;fnn&quot;, 
    )</code></pre><p>where <code>project_name</code> the name of the related project, <code>model_name</code> the name of the model when saving on the database, <code>io</code> the name of input-output data, <code>computation_solver</code> the solver selected, <code>computation_maximum_time</code> the maximum time of the tune with Fnn and hyperparameters optimization, and <code>model_architecture</code> the mathematical model selected.</p><h3 id="Input-convex-neural-network-(Icnn)"><a class="docs-heading-anchor" href="#Input-convex-neural-network-(Icnn)">Input convex neural network (Icnn)</a><a id="Input-convex-neural-network-(Icnn)-1"></a><a class="docs-heading-anchor-permalink" href="#Input-convex-neural-network-(Icnn)" title="Permalink"></a></h3><p>Icnn is equivalent of the Fnn. A representation of the network with one hidden layer is:</p><p><img src="../fnn.png" alt="icnn-diagram"/></p><p>The Icnn is convex compared to Fnn. As a result, weights have to be non negative and the activation function have to be the <code>relu</code> activation function [7]. The mathematical formulation is equivalent to Fnn:</p><p class="math-container">\[h=\mathcal{G}(v) = g_{h¹}(v)\ \circ g_{h²} (h¹) \circ ... \circ g_{h^{i-1}} (h^{i-2}) \circ g_{h^{i}}(h^{i-1})\]</p><p>where  <span>$h$</span> is the output, <span>$\sigma$</span>is the activation function, <span>$W$</span>is the weighting matrix, <span>$v$</span>is the input vector and <span>$b$</span> is the bias. Also, the Icnn has a non negative <span>$W$</span> matrix and <span>$\sigma$</span> is a relu activation function, such as <span>$\text{relu}:=\text{max}(0,x)$</span>.</p><p>The Icnn is implemented it can be selected with <code>model_architecture</code>:</p><pre><code class="language-julia hljs">julia&gt; model(:tune; 
        project_name = &quot;name&quot;,
        model_name = &quot;model&quot;,
        io = &quot;io_name&quot;,
        computation_solver = &quot;adam&quot;,
        computation_maximum_time = Dates.Minute(5),
        model_architecture = &quot;icnn&quot;, 
    )</code></pre><p>where <code>project_name</code> the name of the related project, <code>model_name</code> the name of the model when saving on the database, <code>io</code> the name of input-output data, <code>computation_solver</code> the solver selected, <code>computation_maximum_time</code> the maximum time of the tune with Fnn and hyperparameters optimization, and <code>model_architecture</code> the mathematical model selected.</p><h3 id="Residual-layer-neural-network-(ResNet)"><a class="docs-heading-anchor" href="#Residual-layer-neural-network-(ResNet)">Residual layer neural network (ResNet)</a><a id="Residual-layer-neural-network-(ResNet)-1"></a><a class="docs-heading-anchor-permalink" href="#Residual-layer-neural-network-(ResNet)" title="Permalink"></a></h3><p>The residual layer networks have been proposed in image recognition to avoid vanishing gradient issues when training deep neural networks with residual value input propagation along the hidden layers [8]. The main feature of the ResNet is a skip connection and addition between each cell [9]:</p><p class="math-container">\[h=v+ g_h (v)\]</p><p>where <span>$h$</span> is the output of a hidden layer, <span>$v$</span> is the input, and <span>$g_h$</span> is the hidden layer <span>$g_{h}(v)=\sigma(Wv+b)$</span>. The ResNet with one hidden layer can be illustrated as:</p><p><img src="../resnet.png" alt="resnet-diagram"/></p><p>Furhtermore, ResNet with one layer is derived from forward Euler integration methods [9]:</p><p class="math-container">\[y[k+1] = y[k]+ \Delta_k g(y[k])\]</p><p>where <span>$y[k+1]$</span>is the solution at <span>$k+1$</span>of ordinary differential equation integration and <span>$\Delta_k$</span>is the sample time.</p><p>The ResNet is implemented with AutomationLabs for dynamical systems identification. It can be selected with <code>model_architecture</code>:</p><pre><code class="language-julia hljs">julia&gt; model(:tune; 
        project_name = &quot;name&quot;,
        model_name = &quot;model&quot;,
        io = &quot;io_name&quot;,
        computation_solver = &quot;adam&quot;,
        computation_maximum_time = Dates.Minute(5),
        model_architecture = &quot;resnet&quot;, 
    )</code></pre><p>where <code>project_name</code> the name of the related project, <code>model_name</code> the name of the model when saving on the database, <code>io</code> the name of input-output data, <code>computation_solver</code> the solver selected, <code>computation_maximum_time</code> the maximum time of the tune with Fnn and hyperparameters optimization, and <code>model_architecture</code> the mathematical model selected.</p><h3 id="Poly-inception-neural-network-(PolyNet)"><a class="docs-heading-anchor" href="#Poly-inception-neural-network-(PolyNet)">Poly-inception neural network (PolyNet)</a><a id="Poly-inception-neural-network-(PolyNet)-1"></a><a class="docs-heading-anchor-permalink" href="#Poly-inception-neural-network-(PolyNet)" title="Permalink"></a></h3><p>The poly-inception neural network have been proposed in image as an enhancement of the ResNet [10].  The PolyNet has a skip connection and multiple-path, the mathematical formulation is:</p><p class="math-container">\[h=v+g_h(v)+g_h (g_h(v))= (I + g_h + g_h^2)(v)\]</p><p>where <span>$h$</span> is the output, <span>$v$</span> is the input, <span>$g_h$</span>is the hidden layer with <span>$g_{h}(v)=\sigma(Wv+b)$</span>. The PolyNet with one hidden layer can be illustrated as:</p><p><img src="../polynet.png" alt="polynet-diagram"/></p><p>Furhtermore, PolyNet with one layer is derived from backward Euler integration methods [9]:</p><p class="math-container">\[y[k+1]=y[k]+\Delta_kg(y[k+1]) \\ y[k+1]-\Delta_kg(y[k+1])=y[k] \\y[k+1] = (I - \Delta_k g)^{-1} y[k]\]</p><p>where <span>$y[k+1]$</span> is the solution at k+1 of ordinary differential equation integration and <span>$\Delta_k$</span>is the sample time. The link with the backword Euler method needs the following approximation: <span>$\frac{1}{1-x} \approx \sum_{n=0}^{\infty} x^n$</span>, leads to :  <span>$(I-\Delta_t f)^{-1} = I + \Delta_t f+ (\Delta_t f)^2 + ... + (\Delta_t f)^n + ...$</span>.</p><p>The PolyNet is implemented with AutomationLabs for dynamical systems identification. It can be selected with <code>model_architecture</code>:</p><pre><code class="language-julia hljs">julia&gt; model(:tune; 
        project_name = &quot;name&quot;,
        model_name = &quot;model&quot;,
        io = &quot;io_name&quot;,
        computation_solver = &quot;adam&quot;,
        computation_maximum_time = Dates.Minute(5),
        model_architecture = &quot;polynet&quot;, 
    )</code></pre><p>where <code>project_name</code> the name of the related project, <code>model_name</code> the name of the model when saving on the database, <code>io</code> the name of input-output data, <code>computation_solver</code> the solver selected, <code>computation_maximum_time</code> the maximum time of the tune with Fnn and hyperparameters optimization, and <code>model_architecture</code> the mathematical model selected.</p><h3 id="Densely-connected-neural-network-(DenseNet)"><a class="docs-heading-anchor" href="#Densely-connected-neural-network-(DenseNet)">Densely connected neural network (DenseNet)</a><a id="Densely-connected-neural-network-(DenseNet)-1"></a><a class="docs-heading-anchor-permalink" href="#Densely-connected-neural-network-(DenseNet)" title="Permalink"></a></h3><p>The Densely connected neural neural network have been proposed in image recognition as an enhancement of the ResNet [11].  The DenseNet has a concatenation of the previous layers, the mathematical formulation is:</p><p class="math-container">\[h^l = g_h(\text{cat}(h^1, ..., h^{l-1}))\]</p><p>where h is the output, <span>$h^i$</span>are the previous outputs of the hidden layers, <span>$\text{cat}$</span>is the contactenation, <span>$g_h= \sigma(Wv+b)$</span>. The DenseNet can be illustrated as:</p><p><img src="../densenet.png" alt="densenet-diagram"/></p><p>The DenseNet is implemented with AutomationLabs for dynamical systems identification. It can be selected with <code>model_architecture</code>:</p><pre><code class="language-julia hljs">julia&gt; model(:tune; 
        project_name = &quot;names&quot;,
        model_name = &quot;model&quot;,
        io = &quot;io_name&quot;,
        computation_solver = &quot;adam&quot;,
        computation_maximum_time = Dates.Minute(5),
        model_architecture = &quot;densenet&quot;, 
    )</code></pre><p>where <code>project_name</code> the name of the related project, <code>model_name</code> the name of the model when saving on the database, <code>io</code> the name of input-output data, <code>computation_solver</code> the solver selected, <code>computation_maximum_time</code> the maximum time of the tune with Fnn and hyperparameters optimization, and <code>model_architecture</code> the mathematical model selected.</p><h3 id="ODE-neural-network-type-1-(NeuralNetODE_type1)"><a class="docs-heading-anchor" href="#ODE-neural-network-type-1-(NeuralNetODE_type1)">ODE neural network type 1 (NeuralNetODE_type1)</a><a id="ODE-neural-network-type-1-(NeuralNetODE_type1)-1"></a><a class="docs-heading-anchor-permalink" href="#ODE-neural-network-type-1-(NeuralNetODE_type1)" title="Permalink"></a></h3><p>Ordinary differential equation neural network (OdeNet) need a numerical ordinary differential equation integration method, rather than to use a discret method. During trainning and infering, the network is discretized with a integration numerical method [12]. The mathematical formulation is:</p><p class="math-container">\[\dot h (t) = g_h(h(t))\]</p><p>where <span>$\dot h(t)$</span> is the derivative and <span>$g_h$</span>the hidden layer such as : <span>$g_h = \sigma (W v + b)$</span>. With AutomationLabs there are two implementation of the OdeNet for dynamical system identification. With the first implementation, the odenet is placed between the input and output layers, and it can be illustrated as:</p><p><img src="../odenet_type1.png" alt="odenet_type1-diagram"/></p><p>The OdeNet is implemented with AutomationLabs for dynamical systems identification. Tt can be selected with <code>model_architecture</code>:</p><pre><code class="language-julia hljs">julia&gt; model(:tune; 
        project_name = &quot;name&quot;,
        model_name = &quot;model&quot;,
        io = &quot;io_name&quot;,
        computation_solver = &quot;adam&quot;,
        computation_maximum_time = Dates.Minute(5),
        model_architecture = &quot;neuralnet_ode_type1&quot;, 
    )</code></pre><p>where <code>project_name</code> the name of the related project, <code>model_name</code> the name of the model when saving on the database, <code>io</code> the name of input-output data, <code>computation_solver</code> the solver selected, <code>computation_maximum_time</code> the maximum time of the tune with Fnn and hyperparameters optimization, and <code>model_architecture</code> the mathematical model selected.</p><h3 id="ODE-neural-network-type-2-(NeuralNetODE_type2)"><a class="docs-heading-anchor" href="#ODE-neural-network-type-2-(NeuralNetODE_type2)">ODE neural network type 2 (NeuralNetODE_type2)</a><a id="ODE-neural-network-type-2-(NeuralNetODE_type2)-1"></a><a class="docs-heading-anchor-permalink" href="#ODE-neural-network-type-2-(NeuralNetODE_type2)" title="Permalink"></a></h3><p>Ordinary differential equation neural network (OdeNet) need a numerical ordinary differential equation integration method, rather than to use a discret method. During trainning and infering, the network is discretized with a integration numerical method [12]. The mathematical formulation is:</p><p class="math-container">\[\dot h (t) = g_h(h(t))\]</p><p>where <span>$\dot h (t)$</span> is the derivative and <span>$g_h$</span> the hidden layer, such as <span>$g_h=\sigma (W v + b)$</span>. With AutomationLabs there are two implementationd of the OdeNet for dynamical system identification. With the second implementation, the network input is sent to the odenet, and it can be illustrated as:</p><p><img src="../odenet_type2.png" alt="odenet_type2-diagram"/></p><p>The OdeNet is implemented with AutomationLabs for dynamical systems identification. It can be selected with <code>model_architecture</code>:</p><pre><code class="language-julia hljs">julia&gt; model(:tune; 
        project_name = &quot;names&quot;,
        model_name = &quot;model&quot;,
        io = &quot;io_name&quot;,
        computation_solver = &quot;adam&quot;,
        computation_maximum_time = Dates.Minute(5),
        model_architecture = &quot;neuralnet_ode_type2&quot;, 
    )</code></pre><p>where <code>project_name</code> the name of the related project, <code>model_name</code> the name of the model when saving on the database, <code>io</code> the name of input-output data, <code>computation_solver</code> the solver selected, <code>computation_maximum_time</code> the maximum time of the tune with Fnn and hyperparameters optimization, and <code>model_architecture</code> the mathematical model selected.</p><h3 id="Radial-basis-function-neural-network-(Rbf)"><a class="docs-heading-anchor" href="#Radial-basis-function-neural-network-(Rbf)">Radial basis function neural network (Rbf)</a><a id="Radial-basis-function-neural-network-(Rbf)-1"></a><a class="docs-heading-anchor-permalink" href="#Radial-basis-function-neural-network-(Rbf)" title="Permalink"></a></h3><h3 id="Recurrent-neural-network-(Rnn)"><a class="docs-heading-anchor" href="#Recurrent-neural-network-(Rnn)">Recurrent neural network (Rnn)</a><a id="Recurrent-neural-network-(Rnn)-1"></a><a class="docs-heading-anchor-permalink" href="#Recurrent-neural-network-(Rnn)" title="Permalink"></a></h3><p>The neuron with recurrence is the simplest to implement, it presents a modification of an artificial neuron with a return to the previous output [13]. The Rnn allows to take into account the temporal dynamics between data compared to the classical artificial neuron that deals with static data [14]. The mathematical formulation is:</p><p class="math-container">\[h[k] = \sigma (W v[k] + U h [k-1] + b)\]</p><p>where <span>$h[k]$</span> is the output of the Rnn cell at k, <span>$\sigma$</span> is the activation function, <span>$W$</span>and <span>$U$</span>are the weights matrices, <span>$h[k-1]$</span> is the output of the cell at <span>$k-1$</span>, and <span>$b$</span> is the bias. The network with Rnn cell as hidden layer can be illustrated as:</p><p><img src="../rnn.png" alt="rnn-diagram"/></p><p>The Rnn is implemented with AutomationLabs for dynamical systems identification. It can be selected with <code>model_architecture</code>:</p><pre><code class="language-julia hljs">julia&gt; model(:tune; 
        project_name = &quot;name&quot;,
        model_name = &quot;model&quot;,
        io = &quot;io_name&quot;,
        computation_solver = &quot;adam&quot;,
        computation_maximum_time = Dates.Minute(5),
        model_architecture = &quot;rnn&quot;, 
    )</code></pre><p>where <code>project_name</code> the name of the related project, <code>model_name</code> the name of the model when saving on the database, <code>io</code> the name of input-output data, <code>computation_solver</code> the solver selected, <code>computation_maximum_time</code> the maximum time of the tune with Rnn and hyperparameters optimization, and <code>model_architecture</code> the mathematical model selected.</p><h3 id="Long-Short-Term-Memory-(Lstm)"><a class="docs-heading-anchor" href="#Long-Short-Term-Memory-(Lstm)">Long Short-Term Memory (Lstm)</a><a id="Long-Short-Term-Memory-(Lstm)-1"></a><a class="docs-heading-anchor-permalink" href="#Long-Short-Term-Memory-(Lstm)" title="Permalink"></a></h3><p>Long short-term memory (LSTM) is a unit with recurrence implementation such as Rnn, and it was first proposed in 1997 [15]. LSTM allows to remedy the difficulty of the vanishing gradient issue to memorise the past inputs/outputs during the training of the Rnn [16]. The mathematical formulation is:</p><p class="math-container">\[\tilde{c} [k] = \text{tanh} (W_c v[k] + U_c h[k-1] + b_c) \\  c[k] = o[k]    \odot c[k-1] + e[k] \odot \tilde{c} [k] \\ h[k] = s[k] \odot \text{tanh}(c[k])\]</p><p>where <span>$\tilde{c}[k]$</span> is the candidat vector, <span>$\text{tanh}$</span> is the activation function. <span>$v[k]$</span> is the input, <span>$U_c, W_c, b_c$</span> are the weights matrices and the bias. <span>$c[k]$</span> is the memory vector, <span>$o[k]$</span> is the output gate and <span>$e[k]$</span> the input gate. <span>$h[k]$</span> is the output of the cell with <span>$s[k]$</span> the output gate. Also, <span>$\odot$</span> is the Hadamard product. The Lstm&#39;s gates are:</p><p class="math-container">\[e[k] = \sigma (W_e v[k] + U_e h[k-1] + b_e) \\ o[k] = \sigma (W_o v[k] + U_o h[k-1] + b_o) \\ s[k] = \sigma (W_s v[k] + U_s h [k-1] + b_s)\]</p><p>where <span>$e[k], o[k], s[k]$</span> are the input, forget and output gates. <span>$W_e, U_e, W_o, U_o, W_s, U_s$</span> are the weighting matrices and <span>$b_e, b_o, b_s$</span> are the bias. The network with Lstm cell as hidden layer can be illustrated as:</p><p><img src="../rnn.png" alt="lstm-diagram"/></p><p>The Lstm is implemented with AutomationLabs for dynamical systems identification. It can be selected with <code>model_architecture</code>:</p><pre><code class="language-julia hljs">julia&gt; model(:tune; 
        project_name = &quot;name&quot;,
        model_name = &quot;model&quot;,
        io = &quot;io_name&quot;,
        computation_solver = &quot;adam&quot;,
        computation_maximum_time = Dates.Minute(5),
        model_architecture = &quot;lstm&quot;, 
    )</code></pre><p>where <code>project_name</code> the name of the related project, <code>model_name</code> the name of the model when saving on the database, <code>io</code> the name of input-output data, <code>computation_solver</code> the solver selected, <code>computation_maximum_time</code> the maximum time of the tuning and hyperparameters optimization, and <code>model_architecture</code> the mathematical model selected.</p><h3 id="Gated-Recurrent-Unit-(Gru)"><a class="docs-heading-anchor" href="#Gated-Recurrent-Unit-(Gru)">Gated Recurrent Unit (Gru)</a><a id="Gated-Recurrent-Unit-(Gru)-1"></a><a class="docs-heading-anchor-permalink" href="#Gated-Recurrent-Unit-(Gru)" title="Permalink"></a></h3><p>Gru is recurrent and it has two gates (update gate and reset gate) [17]. The mathematical formulation of Gru is:</p><p class="math-container">\[h[k] = (1-z[k]) \odot h[k-1] + z[k] \odot \tilde{h}[k] \\ \tilde{h} [k] = \text{tanh}(W_h v[k] + U_h(r[k] \odot h[k-1])) + b_h)\]</p><p>where <span>$h[k]$</span> is the hidden state and <span>$\tilde{h}[k]$</span> is the candidate hidden state. <span>$W_h, U_h$</span> are the weigths matrices, <span>$b_h$</span> the bias and <span>$\text{tanh}$</span> the activation function. <span>$v[k]$</span> is the input and <span>$\odot$</span> is the Hadamard product. Also, <span>$z[k]$</span> is the update gate and <span>$r[k]$</span> is the reset gate, such as:</p><p class="math-container">\[z[k] = \sigma(W_z v[k] + U_z h[k-1] + b_z) \\ r[k] = \sigma (W_r v[k] + U_r h [k-1] + b_r)\]</p><p>where <span>$z[k]$</span> is the update gate, <span>$r[k]$</span> the reset gate, <span>$\sigma$</span> is the sigmoid activation function, <span>$W_z, W_r, U_z, U_r$</span> are the weights matrices, <span>$b_z, b_r$</span> the bias, <span>$v[k]$</span> the input, <span>$h[k-1]$</span> the hidden state at <span>$k-1$</span>. The network with Gru cell as hidden layer can be illustrated as:</p><p><img src="../rnn.png" alt="gru-diagram"/></p><p>The Gru is implemented with AutomationLabs for dynamical systems identification. It can be selected with <code>model_architecture</code>:</p><pre><code class="language-julia hljs">julia&gt; model(:tune; 
        project_name = &quot;name&quot;,
        model_name = &quot;model&quot;,
        io = &quot;io_name&quot;,
        computation_solver = &quot;adam&quot;,
        computation_maximum_time = Dates.Minute(5),
        model_architecture = &quot;gru&quot;, 
    )</code></pre><p>where <code>project_name</code> the name of the related project, <code>model_name</code> the name of the model when saving on the database, <code>io</code> the name of input-output data, <code>computation_solver</code> the solver selected, <code>computation_maximum_time</code> the maximum time of the tuning and hyperparameters optimization, and <code>model_architecture</code> the mathematical model selected.</p><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><p>[1] McCulloch, W. S., Pitts, W. H., Lettvin, J. Y., &amp; Maturana, H. R. (1959). What the frog’s eye tells the frog’s brain. <em>Proceedings of the IRE</em>, <em>47</em>(11), 1940-1951.</p><p>[2] Chakraverty, S., Sahoo, D. M., &amp; Mahato, N. R. (2019). McCulloch–Pitts neural network model. In <em>Concepts of Soft Computing</em> (pp. 167-173). Springer, Singapore.</p><p>[3] LeCun, Y., Bengio, Y., &amp; Hinton, G. (2015). Deep learning. <em>nature</em>, <em>521</em>(7553), 436-444.</p><p>[4] Cybenko, G. (1989). Approximation by superpositions of a sigmoidal function. <em>Mathematics of control, signals and systems</em>, <em>2</em>(4), 303-314.</p><p>[5] Hornik, K. (1991). Approximation capabilities of multilayer feedforward networks. <em>Neural networks</em>, <em>4</em>(2), 251-257.</p><p>[6] Kim, K. K. K., Patrón, E. R., &amp; Braatz, R. D. (2018). Standard representation and unified stability analysis for dynamic artificial neural network models. <em>Neural Networks</em>, <em>98</em>, 251-262.</p><p>[7] Amos, B., Xu, L., &amp; Kolter, J. Z. (2017, July). Input convex neural networks. In <em>International Conference on Machine Learning</em> (pp. 146-155). PMLR.</p><p>[8] He, K., Zhang, X., Ren, S., &amp; Sun, J. (2016). Deep residual learning for image recognition. In <em>Proceedings of the IEEE conference on computer vision and pattern recognition</em> (pp. 770-778).</p><p>[9] Blaud, P. C., Chevrel, P., Claveau, F., Haurant, P., &amp; Mouraud, A. (2022). ResNet and PolyNet based identification and (MPC) control of dynamical systems: a promising way. <em>IEEE Access</em>.</p><p>[10] Zhang, X., Li, Z., Change Loy, C., &amp; Lin, D. (2017). Polynet: A pursuit of structural diversity in very deep networks. In <em>Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition</em> (pp. 718-726).</p><p>[11] Huang, G., Liu, Z., Van Der Maaten, L., &amp; Weinberger, K. Q. (2017). Densely connected convolutional networks. In <em>Proceedings of the IEEE conference on computer vision and pattern recognition</em> (pp. 4700-4708).</p><p>[12] Chen, R. T., Rubanova, Y., Bettencourt, J., &amp; Duvenaud, D. K. (2018). Neural ordinary differential equations. <em>Advances in neural information processing systems</em>, <em>31</em>.</p><p>[13] Banerjee, K., Georganas, E., Kalamkar, D. D., Ziv, B., Segal, E., Anderson, C., &amp; Heinecke, A. (2019). Optimizing deep learning rnn topologies on intel architecture. <em>Supercomputing Frontiers and Innovations</em>, <em>6</em>(3), 64-85.</p><p>[14] Schuster, M., &amp; Paliwal, K. K. (1997). Bidirectional recurrent neural networks. <em>IEEE transactions on Signal Processing</em>, <em>45</em>(11), 2673-2681.</p><p>[15] Hochreiter, S., &amp; Schmidhuber, J. (1997). Long short-term memory. <em>Neural computation</em>, <em>9</em>(8), 1735-1780.</p><p>[16] Greff, K., Srivastava, R. K., Koutník, J., Steunebrink, B. R., &amp; Schmidhuber, J. (2016). LSTM: A search space odyssey. <em>IEEE transactions on neural networks and learning systems</em>, <em>28</em>(10), 2222-2232.</p><p>[17] Dey, R., &amp; Salem, F. M. (2017, August). Gate-variants of gated recurrent unit (GRU) neural networks. In <em>2017 IEEE 60th international midwest symposium on circuits and systems (MWSCAS)</em> (pp. 1597-1600). IEEE.</p><h3 id><a class="docs-heading-anchor" href="#"></a><a id="-1"></a><a class="docs-heading-anchor-permalink" href="#" title="Permalink"></a></h3></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../administrate-models/">« Interact with models</a><a class="docs-footer-nextpage" href="../hyperparameters-optimization/">Hyperparameters optimization »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 31 March 2023 16:07">Friday 31 March 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
